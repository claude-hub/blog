# React

## React 18 更新内容

createRoot

## React 运行原理

React 的渲染流程可以分为以下几个步骤：

1. **初始化渲染**：
   - 当组件首次被渲染时，React 会调用组件的 `render` 方法（或函数组件的主体），生成虚拟 DOM。
   - 虚拟 DOM 被转换为实际的 DOM，并插入到页面中。
2. **状态更新**：
   - 当组件的状态（state）或属性（props）发生变化时，React 会再次调用 `render` 方法，生成新的虚拟 DOM。
   - React 使用 Diff 算法比较新旧虚拟 DOM 的差异。
   - 只有发生变化的部分会被更新到实际的 DOM 中。
3. **生命周期方法**：
   - 组件在不同的生命周期阶段会有不同的方法被调用，如 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount`。
   - 这些方法允许开发者在组件的不同阶段执行特定的操作，如数据获取、DOM 操作等。

## React Fiber 架构 & 如何中断的


```js
// 假设这是我们的调度器函数
function requestWork(callback) {
  // 在实际应用中，这里可能会使用 requestIdleCallback 或者 polyfill
  setTimeout(() => callback(), 0);
}

// 创建一个虚拟的 Fiber 树（省略了之前的创建过程）

let workInProgress = rootFiber; // 当前正在处理的 Fiber 节点
const timeSlice = 5; // 每个时间片的长度，例如 5ms

function performUnitOfWork(fiber) {
  // 执行一些与当前 Fiber 节点相关的工作
  console.log(`Working on: ${fiber.element}`);

  // 如果有子节点，那么下一个工作单元将是第一个子节点
  if (fiber.child) {
    return fiber.child;
  }

  // 否则，找到下一个兄弟节点或返回父节点
  let nextFiber = fiber;
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling;
    }
    nextFiber = nextFiber.parent;
  }

  // 如果没有更多的节点可以处理了，结束整个过程
  return null;
}

function workLoop(deadline) {
  // 记录开始时间
  const startTime = Date.now();

  // 如果还有剩余时间并且还有工作要做
  while (workInProgress && Date.now() - startTime < timeSlice) {
    workInProgress = performUnitOfWork(workInProgress);
  }

  // 如果还有更多工作要做，安排下一次工作
  if (workInProgress) {
    requestWork(() => workLoop(Date.now() + timeSlice));
  } else {
    console.log('All work completed.');
  }
}

// 开始工作
requestWork(() => workLoop(Date.now() + timeSlice));
```


## React 任务调度

最小堆实现高优任务调度



## React Diff 算法

