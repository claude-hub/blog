# React

## React 18 更新内容

createRoot

## React 运行原理

React 的渲染流程可以分为以下几个步骤：

1. **初始化渲染**：
   - 当组件首次被渲染时，React 会调用组件的 `render` 方法（或函数组件的主体），生成虚拟 DOM。
   - 虚拟 DOM 被转换为实际的 DOM，并插入到页面中。
2. **状态更新**：
   - 当组件的状态（state）或属性（props）发生变化时，React 会再次调用 `render` 方法，生成新的虚拟 DOM。
   - React 使用 Diff 算法比较新旧虚拟 DOM 的差异。
   - 只有发生变化的部分会被更新到实际的 DOM 中。
3. **生命周期方法**：
   - 组件在不同的生命周期阶段会有不同的方法被调用，如 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount`。
   - 这些方法允许开发者在组件的不同阶段执行特定的操作，如数据获取、DOM 操作等。

## React Fiber 架构 & 如何中断的


```js
// 假设这是我们的调度器函数
function requestWork(callback) {
  // 在实际应用中，这里可能会使用 requestIdleCallback 或者 polyfill
  setTimeout(() => callback(), 0);
}

// 创建一个虚拟的 Fiber 树（省略了之前的创建过程）

let workInProgress = rootFiber; // 当前正在处理的 Fiber 节点
const timeSlice = 5; // 每个时间片的长度，例如 5ms

function performUnitOfWork(fiber) {
  // 执行一些与当前 Fiber 节点相关的工作
  console.log(`Working on: ${fiber.element}`);

  // 如果有子节点，那么下一个工作单元将是第一个子节点
  if (fiber.child) {
    return fiber.child;
  }

  // 否则，找到下一个兄弟节点或返回父节点
  let nextFiber = fiber;
  while (nextFiber) {
    if (nextFiber.sibling) {
      return nextFiber.sibling;
    }
    nextFiber = nextFiber.parent;
  }

  // 如果没有更多的节点可以处理了，结束整个过程
  return null;
}

function workLoop(deadline) {
  // 记录开始时间
  const startTime = Date.now();

  // 如果还有剩余时间并且还有工作要做
  while (workInProgress && Date.now() - startTime < timeSlice) {
    workInProgress = performUnitOfWork(workInProgress);
  }

  // 如果还有更多工作要做，安排下一次工作
  if (workInProgress) {
    requestWork(() => workLoop(Date.now() + timeSlice));
  } else {
    console.log('All work completed.');
  }
}

// 开始工作
requestWork(() => workLoop(Date.now() + timeSlice));
```


## React 任务调度

最小堆实现高优任务调度



## React Diff 算法

React 使用虚拟 DOM（Virtual DOM）来提高应用性能。当 React 组件的状态（state）或属性（props）发生变化时，React 会重新渲染组件的虚拟 DOM 树，并与之前的虚拟 DOM 树进行比较，这个过程称为“diff”（差异计算）。通过这个过程，React 能够确定最小的更新集合并将其应用到实际的 DOM 中，从而减少不必要的 DOM 操作，提高应用性能。

### React Diff 的主要步骤

1. **元素类型对比**：
   - 首先，React 会检查两个虚拟 DOM 节点的类型是否相同。如果类型不同（比如从 `<div>` 变为 `<span>`），那么 React 会直接卸载旧的节点及其所有子节点，并创建新的节点。
   
2. **属性对比**：
   - 如果节点类型相同，React 接着会对比两个节点的属性（props）。对于属性的变化，React 会更新实际 DOM 节点的相应属性值。

3. **子节点递归对比**：
   - 对于具有子节点的元素，React 会对子节点执行相同的 diff 过程。为了优化这一过程，React 实现了一个高效的 diff 算法，该算法基于以下假设：
     - 两个不同类型的元素会产生完全不同的树，因此 React 会重新构建整个子树。
     - 开发者可以通过 `key` 属性来标识列表中的每个元素，这有助于 React 在更新时识别哪些元素已经存在，哪些是新增或移除的。
   - 利用这些假设，React 可以有效地对列表项进行更新、插入、删除等操作，而不需要对整个列表进行重新渲染。

4. **使用 key 优化**：
   - 当处理列表或集合时，给每个元素分配一个唯一的 `key` 属性可以帮助 React 识别哪些元素发生了变化。这可以显著提升 diff 的效率，因为 React 可以快速定位到需要更新的具体项目，而不是对整个列表进行重新排序或重建。

5. **最小化 DOM 操作**：
   - 在完成上述步骤后，React 会收集所有的变更信息，并尽可能地将它们批处理成一次性的 DOM 更新操作。这样可以减少与浏览器的交互次数，进一步提升性能。

### 总结

React 的 diff 算法是一个高度优化的过程，它通过一系列策略来确保在更新界面时能够达到最佳性能。通过元素类型对比、属性对比、递归子节点对比以及利用 `key` 属性等方法，React 能够高效地找出并应用最小的更新集，从而避免了不必要的 DOM 操作。